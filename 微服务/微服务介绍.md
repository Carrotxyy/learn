## 微服务介绍

总结记录，毛剑直播课的内容



#### 单体架构

当一个单体架构服务，随着功能模块的不断迭代，慢慢的演变成一个巨石服务

此时带来许多问题：

- 如果单体应用出现问题，整个系统将瘫痪

- 单个应用功能太过集中，复杂度太高，导致任何单个开发人员都无法完整的读懂，开发成本巨大
- 大量业务代码，代码的可读性、维护性很差，修改代码、添加代码的周期很长
- `CICD` 持续开发、持续交付、持续部署 变的困难



#### SOA 微服务起源

`SOA`  面向服务的架构模式

微服务是 `SOA` 的实践，升华



#### 微服务定义

分而治之，独立运行

关注单一业务，一个服务既是一个业务模块，

服务间采用轻量级通讯机制（http,grpc）

可以独立自动化部署

- 原子服务

- 独立进程

- 隔离部署

- 去中心化服务治理

  - 数据去中心化

    每个服务独享数据储存服务（数据库，缓存）

  - 治理去中心化

  - 技术去中心化

    技术去中心化也要结合实际情况选择，要是每个服务使用不同的语言、技术栈，维护成本也很高



#### 微服务的不足

- 多数据库架构，带来数据一致性问题

- 服务与服务之间使用 `rpc` ，`http`，`消息中间件`进行消息的传递 ，必须在代码中处理上下游消息处理过慢，甚至服务不可用的情况
- 当某个服务升级迭代，可能会波及大量上下游的服务进行修改
- 测试难度大



#### 自动化

开发、调试、测试、监控和部署自动化

- CICD 

  持续集成、持续交付和持续部署

  Gitlab + Gitlab Hooks + K8s

- Testing

  搭建测试环境，单元测试，API测试

- 运行时

  容器编排 K8S，服务监控 Prometheus， 日志管理 ELK



#### 可用性

分布式可用性设计，必须要包括一下所有问题：

- 隔离
- 超时控制
- 负载保护
- 限流
- 降级
- 重试
- 负载均衡



#### 兼容性

发送时保守，接收是开放

发送数据时要尽可能的最小化，接收数据应该最大容忍冗余数据



#### 微服务整体架构设计

![1625391727889](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1625391727889.png)

**网关**

负责路由分发、安全认证、限流、熔断

**BFF**

按照业务设计粗粒度的 API， 进行大量的 dataset join ，提升客户端交互体验

**微服务**

 每一个服务对应单一职责